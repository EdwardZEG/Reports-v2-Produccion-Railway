import { Request, Response, NextFunction, RequestHandler } from 'express';
import DeviceReport from '../models/DeviceReport';
import DeviceCatalog from '../models/DeviceCatalog';
import PeriodoMP from '../models/PeriodoMP';
import { AppError } from '../errors/customErrors';
import mongoose from 'mongoose';

/**
 * Crear un nuevo reporte de dispositivo
 */
export const createDeviceReport = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const {
      deviceCatalogId,
      colaborador,
      especialidad,
      WorkEvidence,
      DeviceEvidence,
      ViewEvidence,
      manualUploadReason,
      note,
      // Campos para trabajo colaborativo
      esColaborativo,
      colaboradores,
      tipoParticipacion
    } = req.body;

    if (!deviceCatalogId || !colaborador || !especialidad) {
      return next(new AppError('deviceCatalogId, colaborador y especialidad son requeridos', 400));
    }

    // Verificar que el dispositivo existe en el cat√°logo
    const catalogDevice = await DeviceCatalog.findById(deviceCatalogId);
    if (!catalogDevice) {
      return next(new AppError('Dispositivo no encontrado en cat√°logo', 404));
    }

    // Preparar datos del reporte
    const reportData: any = {
      deviceCatalog: deviceCatalogId,
      colaborador: new mongoose.Types.ObjectId(colaborador),
      especialidad: new mongoose.Types.ObjectId(especialidad),
      fechaReporte: new Date(),
      WorkEvidence,
      DeviceEvidence,
      ViewEvidence,
      manualUploadReason,
      note,
      estado: 'completado',
      asignado: false,
      completado: true,
      fechaCompletado: new Date()
    };

    // Agregar informaci√≥n colaborativa si aplica
    if (esColaborativo && colaboradores && colaboradores.length > 0) {
      reportData.esColaborativo = true;
      reportData.colaboradores = colaboradores.map((colId: string) => new mongoose.Types.ObjectId(colId));
      
      if (tipoParticipacion && Array.isArray(tipoParticipacion)) {
        reportData.tipoParticipacion = tipoParticipacion.map((participacion: any) => ({
          colaborador: new mongoose.Types.ObjectId(participacion.colaborador),
          rol: participacion.rol,
          descripcion: participacion.descripcion
        }));
      }
      
      console.log('üë• Creando reporte colaborativo con:', colaboradores.length, 'colaboradores');
    }

    // Crear el reporte
    const deviceReport = await DeviceReport.create(reportData);

    // Hacer populate para devolver datos completos
    await deviceReport.populate([
      { path: 'deviceCatalog' },
      { path: 'colaborador', select: 'name email' },
      { path: 'especialidad', select: 'name' }
    ]);

    res.status(201).json({
      success: true,
      message: 'Reporte de dispositivo creado exitosamente',
      data: deviceReport
    });

  } catch (error: any) {
    console.error('Error creando reporte de dispositivo:', error);
    return next(new AppError('Error creando reporte de dispositivo', 500));
  }
};

/**
 * Obtener reportes con filtros y paginaci√≥n
 */
export const getDeviceReports = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const {
      page = 1,
      limit = 20,
      colaborador,
      especialidad,
      fechaInicio,
      fechaFinal,
      estado,
      identifier,
      ubication,
      asignado,
      completado
    } = req.query;

    const filter: any = {};

    // Filtros de colaborador y especialidad
    if (colaborador) {
      const mongoose = require('mongoose');
      const ids = (colaborador as string).split(',');
      const objectIds = ids.map(id => new mongoose.Types.ObjectId(id));
      filter.colaborador = { $in: objectIds };
    }

    if (especialidad) {
      filter.especialidad = new mongoose.Types.ObjectId(especialidad as string);
    }

    // Filtros de fecha
    if (fechaInicio || fechaFinal) {
      filter.fechaReporte = {};
      if (fechaInicio) {
        filter.fechaReporte.$gte = new Date(fechaInicio as string);
      }
      if (fechaFinal) {
        filter.fechaReporte.$lte = new Date(fechaFinal as string);
      }
    }

    // Filtros de estado
    if (estado) {
      filter.estado = estado;
    }

    if (asignado !== undefined) {
      filter.asignado = asignado === 'true';
    }

    if (completado !== undefined) {
      filter.completado = completado === 'true';
    }

    const skip = (parseInt(page as string) - 1) * parseInt(limit as string);

    // Pipeline de agregaci√≥n para filtrar por datos del dispositivo
    const pipeline: any[] = [
      {
        $lookup: {
          from: 'devicecatalogs',
          localField: 'deviceCatalog',
          foreignField: '_id',
          as: 'device'
        }
      },
      { $unwind: '$device' }
    ];

    // Agregar filtros de dispositivo si est√°n presentes
    if (identifier || ubication) {
      const deviceFilter: any = {};
      if (identifier) {
        deviceFilter['device.identifier'] = { $regex: identifier as string, $options: 'i' };
      }
      if (ubication) {
        deviceFilter['device.ubication'] = { $regex: ubication as string, $options: 'i' };
      }
      pipeline.push({ $match: deviceFilter });
    }

    // Agregar filtros generales
    if (Object.keys(filter).length > 0) {
      pipeline.push({ $match: filter });
    }

    // Agregar lookup para colaborador y especialidad
    pipeline.push(
      {
        $lookup: {
          from: 'colaboradors',
          localField: 'colaborador',
          foreignField: '_id',
          as: 'colaboradorInfo'
        }
      },
      {
        $lookup: {
          from: 'especialidads',
          localField: 'especialidad',
          foreignField: '_id',
          as: 'especialidadInfo'
        }
      },
      { $unwind: '$colaboradorInfo' },
      { $unwind: '$especialidadInfo' }
    );

    // Paginaci√≥n y ordenamiento
    pipeline.push(
      { $sort: { fechaReporte: -1 } },
      { $skip: skip },
      { $limit: parseInt(limit as string) }
    );

    const [reports, totalPipeline] = await Promise.all([
      DeviceReport.aggregate(pipeline),
      DeviceReport.aggregate([
        ...pipeline.slice(0, -3), // Excluir sort, skip, limit
        { $count: 'total' }
      ])
    ]);

    const total = totalPipeline[0]?.total || 0;

    res.status(200).json({
      success: true,
      data: reports,
      pagination: {
        page: parseInt(page as string),
        limit: parseInt(limit as string),
        total,
        pages: Math.ceil(total / parseInt(limit as string))
      }
    });

  } catch (error: any) {
    console.error('Error obteniendo reportes:', error);
    return next(new AppError('Error obteniendo reportes de dispositivos', 500));
  }
};

/**
 * Obtener un reporte espec√≠fico por ID
 */
export const getDeviceReportById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;

    const report = await DeviceReport.findById(id)
      .populate('deviceCatalog')
      .populate('colaborador', 'name email')
      .populate('especialidad', 'name')
      .populate('periodoMP', 'nombre fechaInicio fechaFin');

    if (!report) {
      return next(new AppError('Reporte no encontrado', 404));
    }

    res.status(200).json({
      success: true,
      data: report
    });

  } catch (error: any) {
    console.error('Error obteniendo reporte:', error);
    return next(new AppError('Error obteniendo reporte', 500));
  }
};

/**
 * Actualizar estado de un reporte
 */
export const updateDeviceReportStatus = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const { estado, note } = req.body;

    const validStates = ['pendiente', 'en_progreso', 'completado', 'rechazado'];
    if (!validStates.includes(estado)) {
      return next(new AppError('Estado no v√°lido', 400));
    }

    const updateData: any = { estado };
    if (note) updateData.note = note;

    if (estado === 'completado') {
      updateData.completado = true;
      updateData.fechaCompletado = new Date();
    }

    const report = await DeviceReport.findByIdAndUpdate(
      id,
      updateData,
      { new: true }
    ).populate('deviceCatalog');

    if (!report) {
      return next(new AppError('Reporte no encontrado', 404));
    }

    res.status(200).json({
      success: true,
      message: 'Estado del reporte actualizado',
      data: report
    });

  } catch (error: any) {
    console.error('Error actualizando reporte:', error);
    return next(new AppError('Error actualizando reporte', 500));
  }
};

/**
 * Eliminar un reporte
 */
export const deleteDeviceReport = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;

    // Primero obtener el reporte para saber qu√© dispositivo revertir
    const report = await DeviceReport.findById(id);

    if (!report) {
      return next(new AppError('Reporte no encontrado', 404));
    }

    console.log('üóëÔ∏è Eliminando reporte y revirtiendo estado del dispositivo:', {
      reportId: id,
      deviceId: report.deviceCatalog,
      colaboradorId: report.colaborador
    });

    // PASO 1: Eliminar el reporte
    await DeviceReport.findByIdAndDelete(id);

    // PASO 2: Revertir estado del dispositivo en per√≠odo MP
    if (report.deviceCatalog && report.colaborador) {
      try {
        // Importar el modelo PeriodoMP aqu√≠ para evitar dependencias circulares
        const PeriodoMP = require('../models/PeriodoMP').default;
        
        // Buscar el per√≠odo MP que contiene este dispositivo asignado
        const periodo = await PeriodoMP.findOne({
          'dispositivos': {
            $elemMatch: {
              'deviceCatalog': report.deviceCatalog,
              'colaboradorAsignado': report.colaborador,
              'estado': 'completado'
            }
          }
        });

        if (periodo) {
          console.log('üìç Per√≠odo MP encontrado:', periodo._id);
          
          // Encontrar el √≠ndice del dispositivo espec√≠fico
          const deviceIndex = periodo.dispositivos.findIndex((d: any) => 
            d.deviceCatalog.toString() === report.deviceCatalog.toString() && 
            d.colaboradorAsignado?.toString() === report.colaborador.toString()
          );

          if (deviceIndex !== -1) {
            // Revertir el estado a pendiente
            periodo.dispositivos[deviceIndex].estado = 'pendiente';
            periodo.dispositivos[deviceIndex].fechaCompletado = null;
            periodo.dispositivos[deviceIndex].completadoPor = null;
            
            await periodo.save();
            console.log('‚úÖ Estado del dispositivo revertido a pendiente');
          }
        } else {
          console.log('‚ö†Ô∏è No se encontr√≥ per√≠odo MP para revertir estado');
        }
      } catch (revertError) {
        console.error('Error revirtiendo estado del dispositivo:', revertError);
        // No fallar la eliminaci√≥n del reporte por esto
      }
    }

    res.status(200).json({
      success: true,
      message: 'Reporte eliminado y dispositivo revertido a pendiente exitosamente'
    });

  } catch (error: any) {
    console.error('Error eliminando reporte:', error);
    return next(new AppError('Error eliminando reporte', 500));
  }
};

// Funci√≥n getDeviceReportForEdit eliminada - ya no se editan reportes

/**
 * Actualizar reporte completado - editar sin afectar fecha de creaci√≥n
 * PUT /api/device-reports/:id/edit
 */
// Funci√≥n para actualizar reporte con datos JSON (para PATCH /:id)
export const updateDeviceReportJSON = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const {
      type,
      ubication,
      identifier,
      building,
      level,
      WorkEvidence,
      DeviceEvidence,
      ViewEvidence,
      note,
      esColaborativo,
      colaboradores,
      tipoParticipacion,
      especialidad
    } = req.body;

    if (!id || !mongoose.Types.ObjectId.isValid(id)) {
      return next(new AppError('ID de reporte inv√°lido', 400));
    }

    console.log('üîÑ Actualizando reporte con datos JSON:', id);

    // Buscar el reporte existente
    const reporteExistente = await DeviceReport.findById(id);
    if (!reporteExistente) {
      return next(new AppError('Reporte no encontrado', 404));
    }

    // Preparar datos de actualizaci√≥n (preservando datos de creaci√≥n)
    const updateData: any = {};
    
    // Solo actualizar campos que se proporcionan (preservar los originales)
    if (type !== undefined) updateData.type = type;
    if (ubication !== undefined) updateData.ubication = ubication;
    if (identifier !== undefined) updateData.identifier = identifier;
    if (building !== undefined) updateData.building = building;
    if (level !== undefined) updateData.level = level;
    if (note !== undefined) updateData.note = note;
    if (WorkEvidence !== undefined) updateData.WorkEvidence = WorkEvidence;
    if (DeviceEvidence !== undefined) updateData.DeviceEvidence = DeviceEvidence;
    if (ViewEvidence !== undefined) updateData.ViewEvidence = ViewEvidence;
    
    // Siempre actualizar la fecha de modificaci√≥n
    updateData.fechaActualizacion = new Date();

    // Actualizar especialidad si se proporciona
    if (especialidad) {
      updateData.especialidad = new mongoose.Types.ObjectId(especialidad);
    }

    // Agregar informaci√≥n colaborativa si aplica
    if (esColaborativo && colaboradores && colaboradores.length > 0) {
      updateData.esColaborativo = true;
      updateData.colaboradores = colaboradores.map((colId: string) => new mongoose.Types.ObjectId(colId));
      
      if (tipoParticipacion && Array.isArray(tipoParticipacion)) {
        updateData.tipoParticipacion = tipoParticipacion.map((participacion: any) => ({
          colaborador: new mongoose.Types.ObjectId(participacion.colaborador),
          rol: participacion.rol,
          descripcion: participacion.descripcion
        }));
      }
      
      console.log('üë• Actualizando reporte colaborativo con:', colaboradores.length, 'colaboradores');
    } else {
      updateData.esColaborativo = false;
      updateData.colaboradores = [];
      updateData.tipoParticipacion = [];
    }

    // Actualizar el reporte
    const reporteActualizado = await DeviceReport.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    ).populate([
      { path: 'deviceCatalog' },
      { path: 'colaborador', select: 'name email' },
      { path: 'especialidad', select: 'name' }
    ]);

    console.log('‚úÖ Reporte actualizado exitosamente');

    res.status(200).json({
      success: true,
      message: 'Reporte de dispositivo actualizado exitosamente',
      data: reporteActualizado
    });

  } catch (error: any) {
    console.error('Error actualizando reporte de dispositivo:', error);
    return next(new AppError('Error actualizando reporte de dispositivo', 500));
  }
};

// Funci√≥n updateDeviceReport eliminada - ya no se editan reportes
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const {
      note,
      manualUploadReason,
      esColaborativo,
      colaboradores,
      tipoParticipacion,
      especialidad
    } = req.body;

    // Manejar archivos subidos
    const files = req.files as {
      WorkEvidence?: Express.Multer.File[];
      DeviceEvidence?: Express.Multer.File[];
      ViewEvidence?: Express.Multer.File[];
    };

    if (!id || !mongoose.Types.ObjectId.isValid(id)) {
      return next(new AppError('ID de reporte inv√°lido', 400));
    }

    console.log('üîÑ Actualizando reporte:', id);
    console.log('üìÅ Archivos recibidos:', {
      WorkEvidence: files?.WorkEvidence?.length || 0,
      DeviceEvidence: files?.DeviceEvidence?.length || 0,
      ViewEvidence: files?.ViewEvidence?.length || 0
    });

    // Buscar el reporte existente
    const reporteExistente = await DeviceReport.findById(id);
    if (!reporteExistente) {
      return next(new AppError('Reporte no encontrado', 404));
    }

    // Verificar que est√° completado
    if (!reporteExistente.completado) {
      return next(new AppError('Solo se pueden editar reportes completados', 400));
    }

    // Funci√≥n para convertir archivos a Data URI Base64
    const toDataUri = (file?: Express.Multer.File) => {
      if (!file) return null;
      const mime = file.mimetype;
      const b64 = file.buffer.toString('base64');
      return `data:${mime};base64,${b64}`;
    };

    // Preparar campos a actualizar (sin afectar fechas de creaci√≥n)
    const camposActualizables: any = {
      note,
      manualUploadReason,
      esColaborativo: esColaborativo || false,
      updatedAt: new Date() // Solo actualizar fecha de modificaci√≥n
    };

    // Actualizar im√°genes solo si se subieron nuevas
    if (files?.WorkEvidence?.[0]) {
      camposActualizables.WorkEvidence = toDataUri(files.WorkEvidence[0]);
      console.log('üì∏ Actualizando WorkEvidence');
    }
    if (files?.DeviceEvidence?.[0]) {
      camposActualizables.DeviceEvidence = toDataUri(files.DeviceEvidence[0]);
      console.log('üì∏ Actualizando DeviceEvidence');
    }
    if (files?.ViewEvidence?.[0]) {
      camposActualizables.ViewEvidence = toDataUri(files.ViewEvidence[0]);
      console.log('üì∏ Actualizando ViewEvidence');
    }

    // Actualizar especialidad si se proporciona
    if (especialidad) {
      camposActualizables.especialidad = new mongoose.Types.ObjectId(especialidad);
      console.log('üìù Actualizando especialidad');
    }

    // Actualizar participaci√≥n colaborativa si aplica
    if (esColaborativo && tipoParticipacion && Array.isArray(tipoParticipacion)) {
      camposActualizables.tipoParticipacion = tipoParticipacion.map((tp: any) => ({
        colaborador: new mongoose.Types.ObjectId(tp.colaborador),
        rol: tp.rol || 'colaborador'
      }));
    }

    console.log('üìù Campos a actualizar:', Object.keys(camposActualizables));

    // Actualizar reporte manteniendo fechas originales
    const reporteActualizado = await DeviceReport.findByIdAndUpdate(
      id,
      { $set: camposActualizables },
      { 
        new: true, 
        runValidators: true 
      }
    )
    .populate('deviceCatalog', 'identifier type ubication')
    .populate('colaborador', 'nombre apellido_paterno correo')
    .populate('especialidad', 'nombre')
    .populate('tipoParticipacion.colaborador', 'nombre apellido_paterno correo');

    console.log('‚úÖ Reporte actualizado exitosamente');

    res.status(200).json({
      success: true,
      message: 'Reporte actualizado exitosamente',
      data: reporteActualizado
    });

  } catch (error: any) {
    console.error('Error actualizando reporte:', error);
    return next(new AppError('Error actualizando reporte', 500));
  }
};

/**
 * Buscar reportes por deviceCatalogId y colaboradorId
 * GET /api/device-reports/search
 */
export const findDeviceReportByDeviceAndColaborador: RequestHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { deviceCatalogId, colaboradorId } = req.query;
    
    if (!deviceCatalogId || !colaboradorId) {
      return next(new AppError('deviceCatalogId y colaboradorId son requeridos', 400));
    }

    console.log('üîç Buscando reporte completado:', { deviceCatalogId, colaboradorId });

    const reporte = await DeviceReport.findOne({
      deviceCatalog: deviceCatalogId,
      colaborador: colaboradorId,
      completado: true
    })
    .populate('deviceCatalog', 'identifier type ubication building level')
    .populate('colaborador', 'nombre apellido_paterno correo')
    .sort({ fechaCompletado: -1 }) // M√°s reciente primero
    .lean();

    if (!reporte) {
      res.status(404).json({
        success: false,
        message: 'No se encontr√≥ reporte completado para este dispositivo y colaborador'
      });
      return;
    }

    console.log('‚úÖ Reporte encontrado:', reporte._id);
    
    res.status(200).json({
      success: true,
      data: reporte
    });

  } catch (error: any) {
    console.error('Error buscando reporte:', error);
    return next(new AppError('Error buscando reporte', 500));
  }
};